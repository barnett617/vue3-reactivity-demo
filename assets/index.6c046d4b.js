import{o as e,c as o,r as t,a as l,w as c,n,b as a,d as r,e as s,f as u,g as d}from"./vendor.b99ea99b.js";const v={setup:l=>(console.log("-----ref start-----"),console.time("createRef"),t(100),console.timeEnd("createRef"),(()=>{let e=0;const o=t(100);o.value=e++,console.log("write ref",o.value)})(),(()=>{const e=t(100).value;console.log("read ref",e)})(),(()=>{let e=0;const o=t(100);o.value=e++;const l=o.value;console.log("write/read ref",o.value,l)})(),console.log("-----ref end-----"),(t,l)=>(e(),o("h1",null,"ref")))};console.log("-----computed start-----"),(()=>{console.time("createComputed");const e=l((()=>100));console.timeEnd("createComputed"),console.log("createComputed",e.value)})(),(()=>{const e=t(100);e.value=0,console.log("write independent ref dep",e.value)})(),(()=>{const e=t(100);l((()=>2*e.value));let o=0;e.value=o++,console.log("write ref, don't read computed (never invoked)")})(),(()=>{const e=t(100);l((()=>2*e.value)).value;let o=0;e.value=o++,console.log("write ref, don't read computed (invoked)")})(),(()=>{const e=t(100),o=l((()=>2*e.value));let c=0;e.value=c++;const n=o.value;console.log("write ref, read computed",n)})(),(()=>{const e=t(100);for(let t=0,c=1e3;t<c;t++)l((()=>2*e.value));let o=0;e.value=o++,console.log("write ref, don't read 1000 computeds (never invoked)")})(),(()=>{const e=t(100);for(let t=0,c=1e3;t<c;t++){l((()=>2*e.value)).value}let o=0;e.value=o++,console.log("write ref, don't read 1000 computeds (invoked)")})(),(()=>{const e=t(100),o=[];for(let t=0,n=1e3;t<n;t++){const t=l((()=>2*e.value));t.value,o.push(t)}let c=0;e.value=c++,o.forEach((e=>e.value)),console.log("write ref, read 1000 computeds")})(),(()=>{const e=[];for(let l=0,r=1e3;l<r;l++)e.push(t(l));const o=l((()=>{let o=0;return e.forEach((e=>o+=e.value)),o}));let c=0;const n=e.length;e[c++%n].value++;const a=o.value;console.log("1000 refs, 1 computed",a),console.log("0~999 sum",499500)})(),console.log("-----computed end-----");const i={};i.render=function(t,l,c,n,a,r){return e(),o("h1",null,"computed")};console.log("-----watch start-----"),(()=>{const e=t(100),o=c(e,(e=>{}));console.log("create watcher",o)})(),(()=>{const e=t(100);c(e,(e=>{}));let o=0;e.value=o++,console.log("update ref to trigger watcher (schedule but not executed)")})(),(()=>{const e=t(100);c(e,(e=>{}));let o=0;e.value=o++,console.log("nextTick",n),n((()=>console.log("watch next tick"))),console.log("update ref to trigger watcher (executed)")})(),console.log("-----watch end-----");const g={};g.render=function(t,l,c,n,a,r){return e(),o("h1",null,"watch")};console.log("-----watch effect start-----"),(()=>{const e=a((()=>{}));console.log("create watcher effect",e)})(),(()=>{const e=t(100);a(e,(e=>{e.value}));let o=0;e.value=o++,console.log("update ref to trigger watchEffect (schedule but not executed)")})(),(()=>{const e=t(100);a(e,(e=>{e.value}));let o=0;e.value=o++,n((()=>console.log("watch effect next tick"))),console.log("update ref to trigger watchEffect (executed)")})(),console.log("-----watch effect end-----");const p={};p.render=function(t,l,c,n,a,r){return e(),o("h1",null,"watch effect")};console.log("-----mix start-----"),(()=>{const e=t(100),o=l((()=>2*e.value)),r=l((()=>2*o.value)),s=t(10);c(r,(e=>{s.value=e})),a((()=>{o.value,s.value})),e.value+=50,console.log("mix of dependent refs, computed, watch and watchEffect"),n((()=>console.log("mix next tick",e.value)))})(),console.log("-----mix end-----");const f={};f.render=function(t,l,c,n,a,r){return e(),o("h1",null,"mix")};console.log("-----reactive object start-----"),r({a:1}),(()=>{let e=0;const o=r({a:1});o.a=e++,console.log("write reactive obj property",o)})(),(()=>{const e=r({a:1});l((()=>2*e.a));let o=0;e.a=o++,console.log("write reactive obj, don't read computed (never invoked)")})(),(()=>{const e=r({a:1});l((()=>2*e.a)).value;let o=0;e.a=o++,console.log("write reactive obj, don't read computed (invoked)")})(),(()=>{const e=r({a:1}),o=l((()=>2*e.a));let t=0;e.a=t++;const c=o.value;console.log("write reactive obj, read computed",c)})(),(()=>{const e=r({a:1});for(let t=0,c=1e3;t<c;t++)l((()=>2*e.a));let o=0;e.a=o++,console.log("write reactive obj, don't read 1000 computeds (never invoked)")})(),(()=>{const e=r({a:1});for(let t=0,c=1e3;t<c;t++){l((()=>2*e.a)).value}let o=0;e.a=o++,console.log("write reactive obj, don't read 1000 computeds (invoked)")})(),(()=>{const e=r({a:1}),o=[];for(let c=0,n=1e3;c<n;c++){const t=l((()=>2*e.a));o.push(t)}let t=0;e.a=t++,o.forEach((e=>e.value)),console.log("write reactive obj, read 1000 computeds")})(),(()=>{const e=[];for(let l=0,a=1e3;l<a;l++)e.push(r({a:l}));const o=l((()=>{let o=0;return e.forEach((e=>o+=e.a)),o}));let t=0;const c=e.length;e[t++%c].a++;const n=o.value;console.log("1000 reactive objs, 1 computed",n)})(),console.log("-----reactive object end-----");const m={};function h(e){const o=new Map;for(const t in e)e.hasOwnProperty(t)&&o.set(t,e[t]);return o}m.render=function(t,l,c,n,a,r){return e(),o("h1",null,"reactive object")};console.log("-----reactive map start-----"),(()=>{const e=r(h({a:1}));console.log("create reactive map",e)})(),(()=>{let e=0;const o=r(h({a:1}));o.set("a",e++),console.log("write reactive map property",o)})(),(()=>{const e=r(h({a:1}));l((()=>2*e.get("a")));let o=0;e.set("a",o++),console.log("write reactive map, don't read computed (never invoked)")})(),(()=>{const e=r(h({a:1}));l((()=>2*e.get("a"))).value;let o=0;e.set("a",o++),console.log("write reactive map, don't read computed (invoked)")})(),(()=>{const e=r(h({a:1})),o=l((()=>2*e.get("a")));let t=0;e.set("a",t++),o.value,console.log("write reactive map, read computed")})(),(()=>{const e=new Map;for(let l=0,c=1e3;l<c;l++)e.set(l,l);const o=r(e),t=l((()=>{let e=0;return o.forEach(((o,t)=>{e+=o})),e}));o.set(5e3,o.get(5e3)+1),t.value,console.log("write reactive map (10'000 items), read computed")})(),(()=>{const e=r(h({a:1}));for(let t=0,c=1e3;t<c;t++)l((()=>2*e.get("a")));let o=0;e.set("a",o++),console.log("write reactive map, don't read 1000 computeds (never invoked)")})(),(()=>{const e=r(h({a:1}));for(let t=0,c=1e3;t<c;t++){l((()=>2*e.get("a"))).value}let o=0;e.set("a",o++),console.log("write reactive map, don't read 1000 computeds (invoked)")})(),(()=>{const e=r(h({a:1})),o=[];for(let c=0,n=1e3;c<n;c++){const t=l((()=>2*e.get("a")));o.push(t)}let t=0;e.set("a",t++),o.forEach((e=>e.value)),console.log("write reactive map, read 1000 computeds")})(),(()=>{const e=[];for(let l=0,a=1e3;l<a;l++)e.push(r(h({a:l})));const o=l((()=>{let o=0;return e.forEach((e=>o+=e.get("a"))),o}));let t=0;const c=e.length;e[t++%c].set("a",e[t++%c].get("a")+1);const n=o.value;console.log("1000 reactive maps, 1 computed",n)})(),console.log("-----reactive map end-----");const w={};w.render=function(t,l,c,n,a,r){return e(),o("h1",null,"reactive map")};const b=u("p",null,"open devtool and refresh to see what happens",-1);d({setup:t=>(t,l)=>(e(),o("div",null,[b,s(v),s(i),s(g),s(p),s(f),s(m),s(w)]))}).mount("#app");
